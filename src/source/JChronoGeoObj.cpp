//HEAD_DSCODES
/*
 <DUALSPHYSICS>  Copyright (c) 2023 by Dr Jose M. Dominguez et al. (see http://dual.sphysics.org/index.php/developers/). 

 EPHYSLAB Environmental Physics Laboratory, Universidade de Vigo, Ourense, Spain.
 School of Mechanical, Aerospace and Civil Engineering, University of Manchester, Manchester, U.K.

 This file is part of DualSPHysics. 

 DualSPHysics is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License 
 as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.
 
 DualSPHysics is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details. 

 You should have received a copy of the GNU Lesser General Public License along with DualSPHysics. If not, see <http://www.gnu.org/licenses/>. 
*/

/// \file JChronoGeoObj.cpp \brief Implements the class \ref JChronoGeoObj.

#include "JChronoGeoObj.h"
#include "JBinaryData.h"
#include "Functions.h"

#include <algorithm>
#include <climits>
#include <cfloat>
#include <cstring>

using namespace std;

//##############################################################################
//# JChronoGeoObj
//##############################################################################
//==============================================================================
/// Constructor.
//==============================================================================
JChronoGeoObj::JChronoGeoObj(){
  ClassName="JChronoGeoObj";
  Bdat=NULL;
  Reset();
}

//==============================================================================
/// Destructor.
//==============================================================================
JChronoGeoObj::~JChronoGeoObj(){
  DestructorActive=true;
  Reset();
}

//==============================================================================
/// Initialisation of variables.
//==============================================================================
void JChronoGeoObj::Reset(){
  FmtVersion=0;
  CaseName="";
  DirData="";
  FileData="";
  MkBoundFirst=0;
  delete Bdat; Bdat=NULL;
}

//==============================================================================
/// Loads binary file CaseName_ChronoGeo.cbi4.
//==============================================================================
void JChronoGeoObj::LoadFile(std::string casename){
  Reset();
  CaseName=fun::GetWithoutExtension(fun::GetFile(casename));
  DirData=fun::GetDirWithSlash(fun::GetDirParent(casename));
  FileData=DirData+CaseName+"_ChronoGeo.cbi4";
  //-Checks binary file.
  if(!fun::FileExists(FileData)){
    string tx="File with geometry data for Chrono collisions is missing. ";
    tx=tx+"Note that CASE_ChronoGeo.cbi4 is generated by GenCase v5.4.351 (or higher).";
    Run_ExceptioonFile(tx,FileData);
  }
  //-Loads binary file.
  Bdat=new JBinaryData();
  Bdat->LoadFile(FileData,"ChronoGeo");
  FmtVersion=Bdat->GetvUint("FmtVersion");
  //-Checks file format version.
  if(FmtVersion!=FmtVersionDef)Run_ExceptioonFile(fun::PrintStr(
    "File format version %u does not match with expected version %u."
    ,FmtVersion,FmtVersionDef),FileData);
  //-Loads general variables.
  MkBoundFirst=Bdat->GetvUshort("MkBoundFirst");
}

//==============================================================================
/// Creates OBJ file.
//==============================================================================
void JChronoGeoObj::SavesFileObj(std::string fname,byte normalmode
  ,unsigned npos,const tfloat3* pos,unsigned ntri,const tuint3* vtri
  ,unsigned nqua,const tuint4* vqua)const
{
  std::ofstream pf;
  pf.open(fname.c_str());
  if(pf){
    //-Saves vertices.
    for(unsigned cp=0;cp<npos;cp++){
      const tfloat3 ps=pos[cp];
      pf << fun::PrintStr("v %g %g %g",ps.x,ps.y,ps.z) << endl;
    }
    //-Saves triangles and quads.
    if(normalmode<1 || normalmode>3)Run_ExceptioonFile("Normal mode is unknown.",fname);
    const bool svnormal=(normalmode==1 || normalmode==3);
    const bool svinvert=(normalmode==2 || normalmode==3);
    for(unsigned cs=0;cs<ntri;cs++){
      const tuint3 t=vtri[cs];
      if(svnormal)pf << fun::PrintStr("f %u %u %u",t.x+1,t.y+1,t.z+1) << endl;
      if(svinvert)pf << fun::PrintStr("f %u %u %u",t.x+1,t.z+1,t.y+1) << endl;
    }
    for(unsigned cs=0;cs<nqua;cs++){
      const tuint4 t=vqua[cs];
      if(svnormal)pf << fun::PrintStr("f %u %u %u %u",t.x+1,t.y+1,t.z+1,t.w+1) << endl;
      if(svinvert)pf << fun::PrintStr("f %u %u %u %u",t.x+1,t.w+1,t.z+1,t.y+1) << endl;
    }
    if(pf.fail())Run_ExceptioonFile("File writing failure.",fname);
    pf.close();
  }
  else Run_ExceptioonFile("File creation failure.",fname);
}

//==============================================================================
/// Creates OBJ files and returns the number of created shapes.
//==============================================================================
unsigned JChronoGeoObj::CreateMkObj(std::string filein,std::string filesout
  ,const std::vector<unsigned>& mkbounds,byte normalmode)
{
  if(!Bdat)Run_Exceptioon("No data available.");
  const unsigned nmk=unsigned(mkbounds.size());
  //-Creates OBJ files for each MK.
  unsigned nshapes=0;
  for(unsigned cmk=0;cmk<nmk;cmk++){
    const word mkbound=word(mkbounds[cmk]);
    if(fun::StrUpper(filein)=="AUTOACTUAL")filein="AUTOACTUAL";
    else if(fun::StrUpper(filein)=="AUTODP")filein="AUTODP";
    const string name=filein+fun::PrintStr("_Mkb%04u",mkbound);
    JBinaryData* bd=Bdat->GetItem(name);
    const unsigned np  =(bd? bd->GetvUint("Np"): 0);
    const unsigned ntri=(bd? bd->GetvUint("Ntri"): 0);
    const unsigned nqua=(bd? bd->GetvUint("Nqua"): 0);
    nshapes+=ntri+nqua;
    if(!bd || (ntri+nqua)==0)Run_ExceptioonFile(fun::PrintStr(
      "No geometry available for Model=[%s] and Mk=%u (mkbound=%u)."
      ,filein.c_str(),mkbound+MkBoundFirst,mkbound),FileData);
    if(bd){
      //-Loads data arrays.
      tfloat3* vpos=new tfloat3[np];
      tuint3*  vtri=new tuint3[ntri];
      tuint4*  vqua=new tuint4[nqua];
      bd->CopyArrayData("Pos",np,vpos);
      if(ntri)bd->CopyArrayData("Tri",ntri*3,(unsigned*)vtri);
      if(nqua)bd->CopyArrayData("Qua",nqua*4,(unsigned*)vqua);
      //-Saves obj file.
      const string fileout=filesout+fun::PrintStr("_mkb%04u.obj",mkbound);
      SavesFileObj(fileout,normalmode,np,vpos,ntri,vtri,nqua,vqua);
      //-Free memory.
      delete[] vpos; vpos=NULL;
      delete[] vtri; vtri=NULL;
      delete[] vqua; vqua=NULL;
    }
  }
  return(nshapes);
}

//==============================================================================
/// Creates OBJ file with MK geometry from VTK file. Returns number of created shapes.
//==============================================================================
unsigned JChronoGeoObj::CreateOBJsByMk(std::string casename,std::string filein
  ,std::string filesout,const std::vector<unsigned>& mkbounds,byte normalmode)
{
  JChronoGeoObj gobj;
  gobj.LoadFile(casename);
  return(gobj.CreateMkObj(filein,filesout,mkbounds,normalmode));
}

